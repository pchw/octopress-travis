<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: RubyMotion | ぽっちぽちにしてやんよ]]></title>
  <link href="http://pchw.github.com/blog/categories/rubymotion/atom.xml" rel="self"/>
  <link href="http://pchw.github.com/"/>
  <updated>2012-06-01T00:24:07+09:00</updated>
  <id>http://pchw.github.com/</id>
  <author>
    <name><![CDATA[pchw]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[RubyMotion]Bubble-Wrapを使ってみた]]></title>
    <link href="http://pchw.github.com/blog/2012/05/31/bubblewrap/"/>
    <updated>2012-05-31T22:44:00+09:00</updated>
    <id>http://pchw.github.com/blog/2012/05/31/bubblewrap</id>
    <content type="html"><![CDATA[<p>今日はBubble-Wrapというライブラリを使ってみました．</p>

<p><a href="http://matt.aimonetti.net/BubbleWrap/">Bubble-Wrap</a></p>

<p>Bubble-Wrap はめんどくさいことを簡単にしてくれるヘルパーとかRubyっぽく書けない部分をよりRubyっぽくしてくれるライブラリです．</p>

<p>例えば，<a href="http://pchw.github.com/blog/2012/05/30/resource/">昨日書いた</a>リソースの読み込みの所で，</p>

<pre><code>path = NSBundle.mainBundle.resourcePath.stringByAppendingPathComponent "test.txt"
</code></pre>

<p>とか書きましたけど，<code>NSBundle.mainBundle.resoucePath</code>とかめんどくさいですよね．</p>

<p>それを，</p>

<pre><code>path = resources_path.stringByAppendingPathComponent "text.txt"
</code></pre>

<p>にしてくれたりします．
（他にも色々と<code>documents_path</code>とか<code>notification_center</code>とか）</p>

<pre><code>alert "Hoge"
</code></pre>

<p>とするだけで，</p>

<pre><code>alert = UIAlertView.alloc.initWithTitle "Hoge",
    message: nil,
    delegate: nil,
    cancelButtonTitle: 'OK',
    otherButtonTitles: nil
alert.show
</code></pre>

<p>とやってくれたりするのもあります．</p>

<p>色々ありますが，Wikiを見ても一部しか載っていないので，何が出来るか全部把握するには，<a href="https://github.com/mattetti/BubbleWrap/tree/master/lib/bubble-wrap">Githubでコード</a>を見るしか無いっぽいです．</p>

<p>他にも便利なものがあって，HTTPアクセスやJSONのラッパーも提供されています．
例えば，Twitter APIにアクセスして，取得したJSONのデータのアクセスは</p>

<pre><code>BubbleWrap::HTTP.get("https://api.twitter.com/1/users/show.json?screen_name=TwitterAPI&amp;include_entities=true") do |response|
    json = BubbleWrap::JSON.parse response.body.to_str
    p json['name']
end
</code></pre>

<p>のように書けます．
元が NSURLConnectionを作って，delegateで受けてみたいなことを書かないのと比べるととても簡単です．</p>

<p><code>response</code> も<code>body</code>だけでなく，<code>headers</code>や<code>status_code</code>とか<code>ok?</code>（200 OKかどうかを調べる）などもあります．</p>

<p>他にも，device情報を取ったり，gestureを簡単に扱ったりするものもあるので，有効に活用して素早くRubyMotionでアプリ作って行きましょう！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyMotionでリソース読み込み]]></title>
    <link href="http://pchw.github.com/blog/2012/05/30/resource/"/>
    <updated>2012-05-30T23:37:00+09:00</updated>
    <id>http://pchw.github.com/blog/2012/05/30/resource</id>
    <content type="html"><![CDATA[<p>すごく初歩的なところだけども，RubyMotionで画像やテキストのリソースを<code>.app</code>の中にプリセット保持して使う方法です．</p>

<p>色々と試すときに画像やテキストを使いたい事が多くて，備忘録的に書いておきます．</p>

<p>まず，<code>.app</code>内にリソースを保持するには，<code>/resources</code>に入れておけばOKです．</p>

<p>あとは読み出しですが，画像の場合はすごく簡単で，</p>

<pre><code>UIImage.imageNamed "hoge.png"
</code></pre>

<p>とかすれば，<code>/resources/hoge.png</code> が読み出されます．</p>

<p>テキストとかHTMLファイルとかは，</p>

<pre><code>path = NSBundle.mainBundle.resourcePath.stringByAppendingPathComponent "test.txt"
str = NSString.stringWithContentsOfFile path
</code></pre>

<p>とかすれば<code>NSString</code>で取得できます．</p>

<p><code>NSBundle.mainBundle.resourcePath</code>で<code>/resources</code>に当たる場所のPathが取得できるので，あとは好きにすればOKということですね．</p>

<p>簡単なサンプルを書いといたので，置いときます．</p>

<p><a href="https://github.com/pchw/rm-resource-sample">画像とテキストを読みだしてUILabelとUIImageViewに貼り付けるサンプル</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyMotion 1.8 リリースされてますね]]></title>
    <link href="http://pchw.github.com/blog/2012/05/30/18/"/>
    <updated>2012-05-30T20:52:00+09:00</updated>
    <id>http://pchw.github.com/blog/2012/05/30/18</id>
    <content type="html"><![CDATA[<p>リリース周期はやい！もう1.8が出てます．</p>

<pre><code>$ sudo motion update 
</code></pre>

<p>しましょう！今回は修正が少なめです．</p>

<pre><code>= RubyMotion 1.8 =

  * Fixed a bug in the generation of BridgeSupport files for multiple headers
    directories.
  * When building vendored projects, unset environment variables that could
    potentially make the build to fail.
    https://github.com/HipByte/motion-cocoapods/issues/12
</code></pre>

<ul>
<li>複数のヘッダディレクトリを指定したときのBridgeSupportファイル生成のとこのバグ修正</li>
<li>ベンダープロジェクトをビルドするときに環境変数CCが設定されてない時にビルド失敗する問題の修正．</li>
</ul>


<p>いつも誰かがRubyMotionの新しいバージョン出たって言ってるの見てアップデートしてるのが分かるんだけど，言ってる人はどうやって新しいバージョンが出たって知るんだろう？毎日<code>motion update</code>とかしてるのかな．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyMotion 1.7出てます]]></title>
    <link href="http://pchw.github.com/blog/2012/05/29/17/"/>
    <updated>2012-05-29T08:14:00+09:00</updated>
    <id>http://pchw.github.com/blog/2012/05/29/17</id>
    <content type="html"><![CDATA[<p>RubyMotion 1.7が出てました．</p>

<pre><code>$ sudo motion update
</code></pre>

<p>しましょう！</p>

<p>ところで，RubyMotion がアップデートされたかどうかを素早く知る方法ってないんですかね．</p>

<pre><code>= RubyMotion 1.7 =

  * Fixed a bug in the compiler where the proper signature would not be used
    when defining informal protocol methods with CF types as arguments.
  * Fixed iOS constants to be looked up at demand (when being used) and not
    when the app starts, because certain constants are not set until a certain
    API is called (ex: the kAB... constants of the AddressBook framework).
    This change should also speed up a little bit the app starting time.
  * Fixed a bug in the compiler where very long selectors would be truncated
    and causing exceptions later at runtime.
  * Fixed a bug in the compiler where memory-related selectors (alloc, dealloc,
    retain, release, etc.) could not be defined in Ruby.
  * Fixed a bug in the compiler where NSObject instance methods could not be
    called on classes (ex. MyClass.performSelector(...)).
  * Fixed a bug in the build system where vendored 3rd-party APIs dealing with
    types defined in iOS headers could not be used (ex: enums or structs).
</code></pre>

<ul>
<li>非公式プロトコルでCFタイプを引数にとった時に正しいシグネチャを吐かないことの修正</li>
<li>アプリ開始時のiOS定数発見の部分を修正．この影響でアプリ開始時間がちょっと早くなる．</li>
<li>超長いセレクタが途中で切れて実行時エラーになる問題の修正</li>
<li>メモリ関係（allocとかreleaseとか）がRubyで定義出来なかったのを修正．</li>
<li>NSObjectのインスタンスメソッドをクラスから呼べなかった問題を修正</li>
<li>外部ベンダのライブラリを読み込むやつでiOSヘッダに定義されたenumとかstructsが使われなかった問題を修正</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[RubyMotion]Routableを使ってみた]]></title>
    <link href="http://pchw.github.com/blog/2012/05/28/routable/"/>
    <updated>2012-05-28T12:32:00+09:00</updated>
    <id>http://pchw.github.com/blog/2012/05/28/routable</id>
    <content type="html"><![CDATA[<p>Routableというgemがあるみたいという話を聞いて，使ってみました．</p>

<p><a href="https://github.com/clayallsopp/Routable">Routable - GitHub</a></p>

<h2>インストール</h2>

<pre><code>gem install routable
</code></pre>

<h2>Rakefileの編集</h2>

<pre><code>$:.unshift("/Library/RubyMotion/lib")
require 'motion/project'
require 'routable'
</code></pre>

<p>のように<code>require 'routable'</code>を追加します．</p>

<h2>使い方</h2>

<pre><code>class AppDelegate
  def application(application, didFinishLaunchingWithOptions:launchOptions)
    @window = UIWindow.alloc.initWithFrame UIScreen.mainScreen.applicationFrame
    @window.makeKeyAndVisible

    @rootView = NSBundle.mainBundle.loadNibNamed(
        'RootViewController',
        owner: self,
        options: nil).first

    @router = Routable::Router.router
    @router.navigation_controller = UINavigationController.alloc.init
    @router.navigation_controller.pushViewController(@rootView, animated: false)
    @rootView.title = "TOP"

    @router.map("one", OneViewController)
    @router.map("two/:param", TwoViewController)

    @window.rootViewController = @router.navigation_controller

    @one = @rootView.view.viewWithTag 1
    @one.addTarget(
        self, 
        action: 'onClickOne:', 
        forControlEvents: UIControlEventTouchUpInside)

    @two = @rootView.view.viewWithTag 2
    @two.addTarget(
        self, 
        action: 'onClickTwo:', 
        forControlEvents: UIControlEventTouchUpInside)

    true
  end

  def onClickOne(sender)
    @router.open('one', true)
  end

  def onClickTwo(sender)
    @router.open('two/100', true)
  end
end
</code></pre>

<p>こんな感じで使います．</p>

<p><code>Routable::Router.router</code>を取得して，<code>navigation_controller</code>に<code>UINavigationController</code>を設定しておきます．</p>

<p><code>map(&lt;URL&gt;, &lt;viewController&gt;)</code>のようにすると，そのURL文字列をキーにviewControllerの遷移を書けるようになります．</p>

<p><URL>には<code>hoge/:id</code>のようにパラメータを記述することができて，この場合だと<code>hoge/1</code>とかいう遷移をさせれば，宛先のviewControllerに<code>1</code>というパラメータが渡されます．</p>

<p>遷移する時は<code>open(&lt;URL&gt;, &lt;animation?&gt;)</code>とすれば設定したviewControllerへ遷移出来ます．</p>

<h2>遷移先ViewController</h2>

<pre><code>class TwoViewController &lt; UIViewController
    attr_accessor :param

    def initWithParams(params = {})
        init()
        self.param = params[:param]
        self
    end

    def viewDidLoad
        @label = UILabel.alloc.init
        @label.bounds = [[50, 150],[300, 50]]
        @label.text = "TwoViewController" + self.param.to_s
    end
end
</code></pre>

<p>のようにして，<code>initWithParams</code>で引数を受け取れます．</p>

<h2>問題点</h2>

<p>ViewControllerをコードで場所設定とかすごくめんどくさいので，僕はIBを使います．</p>

<p>しかし，IBを使って<code>resouces/HogeViewController.xib</code>を作って，Controlを配置して，，，というフローを辿ってやると，<code>router.open</code>の時にエラーが出ます．</p>

<p>routerの内部では，<code>HogeViewController.alloc.initWithParams()</code>を呼んでインスタンス化しているわけですが，
xibを使うと，<code>NSBundle.mainBundle.loadNibNamed</code>をしないとダメっぽいんですね．</p>

<p>なので，routerをいじって，mapするときにそれ用の情報を入れてあげるかしないといけません．</p>

<h2>まとめ</h2>

<p>僕はStoryboardを使うと思います．</p>

<p>XCodeが嫌でRubyMotionをやっている人は多いと思うので，コードでControlを配置するのが苦じゃない人にとってはrouterはいいソリューションなんじゃないでしょうか．</p>
]]></content>
  </entry>
  
</feed>
