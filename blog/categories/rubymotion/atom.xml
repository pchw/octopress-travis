<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: RubyMotion | ぽっちぽちにしてやんよ]]></title>
  <link href="http://pchw.github.com/blog/categories/rubymotion/atom.xml" rel="self"/>
  <link href="http://pchw.github.com/"/>
  <updated>2012-05-29T01:23:59+09:00</updated>
  <id>http://pchw.github.com/</id>
  <author>
    <name><![CDATA[pchw]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[RubyMotion]Routableを使ってみた]]></title>
    <link href="http://pchw.github.com/blog/2012/05/28/routable/"/>
    <updated>2012-05-28T12:32:00+09:00</updated>
    <id>http://pchw.github.com/blog/2012/05/28/routable</id>
    <content type="html"><![CDATA[<p>Routableというgemがあるみたいという話を聞いて，使ってみました．</p>

<p><a href="https://github.com/clayallsopp/Routable">Routable - GitHub</a></p>

<h2>インストール</h2>

<pre><code>gem install routable
</code></pre>

<h2>Rakefileの編集</h2>

<pre><code>$:.unshift("/Library/RubyMotion/lib")
require 'motion/project'
require 'routable'
</code></pre>

<p>のように<code>require 'routable'</code>を追加します．</p>

<h2>使い方</h2>

<pre><code>class AppDelegate
  def application(application, didFinishLaunchingWithOptions:launchOptions)
    @window = UIWindow.alloc.initWithFrame UIScreen.mainScreen.applicationFrame
    @window.makeKeyAndVisible

    @rootView = NSBundle.mainBundle.loadNibNamed(
        'RootViewController',
        owner: self,
        options: nil).first

    @router = Routable::Router.router
    @router.navigation_controller = UINavigationController.alloc.init
    @router.navigation_controller.pushViewController(@rootView, animated: false)
    @rootView.title = "TOP"

    @router.map("one", OneViewController)
    @router.map("two/:param", TwoViewController)

    @window.rootViewController = @router.navigation_controller

    @one = @rootView.view.viewWithTag 1
    @one.addTarget(
        self, 
        action: 'onClickOne:', 
        forControlEvents: UIControlEventTouchUpInside)

    @two = @rootView.view.viewWithTag 2
    @two.addTarget(
        self, 
        action: 'onClickTwo:', 
        forControlEvents: UIControlEventTouchUpInside)

    true
  end

  def onClickOne(sender)
    @router.open('one', true)
  end

  def onClickTwo(sender)
    @router.open('two/100', true)
  end
end
</code></pre>

<p>こんな感じで使います．</p>

<p><code>Routable::Router.router</code>を取得して，<code>navigation_controller</code>に<code>UINavigationController</code>を設定しておきます．</p>

<p><code>map(&lt;URL&gt;, &lt;viewController&gt;)</code>のようにすると，そのURL文字列をキーにviewControllerの遷移を書けるようになります．</p>

<p><URL>には<code>hoge/:id</code>のようにパラメータを記述することができて，この場合だと<code>hoge/1</code>とかいう遷移をさせれば，宛先のviewControllerに<code>1</code>というパラメータが渡されます．</p>

<p>遷移する時は<code>open(&lt;URL&gt;, &lt;animation?&gt;)</code>とすれば設定したviewControllerへ遷移出来ます．</p>

<h2>遷移先ViewController</h2>

<pre><code>class TwoViewController &lt; UIViewController
    attr_accessor :param

    def initWithParams(params = {})
        init()
        self.param = params[:param]
        self
    end

    def viewDidLoad
        @label = UILabel.alloc.init
        @label.bounds = [[50, 150],[300, 50]]
        @label.text = "TwoViewController" + self.param.to_s
    end
end
</code></pre>

<p>のようにして，<code>initWithParams</code>で引数を受け取れます．</p>

<h2>問題点</h2>

<p>ViewControllerをコードで場所設定とかすごくめんどくさいので，僕はIBを使います．</p>

<p>しかし，IBを使って<code>resouces/HogeViewController.xib</code>を作って，Controlを配置して，，，というフローを辿ってやると，<code>router.open</code>の時にエラーが出ます．</p>

<p>routerの内部では，<code>HogeViewController.alloc.initWithParams()</code>を呼んでインスタンス化しているわけですが，
xibを使うと，<code>NSBundle.mainBundle.loadNibNamed</code>をしないとダメっぽいんですね．</p>

<p>なので，routerをいじって，mapするときにそれ用の情報を入れてあげるかしないといけません．</p>

<h2>まとめ</h2>

<p>僕はStoryboardを使うと思います．</p>

<p>XCodeが嫌でRubyMotionをやっている人は多いと思うので，コードでControlを配置するのが苦じゃない人にとってはrouterはいいソリューションなんじゃないでしょうか．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[RubyMotion]motion-liveを使ってみよう]]></title>
    <link href="http://pchw.github.com/blog/2012/05/27/live/"/>
    <updated>2012-05-27T11:17:00+09:00</updated>
    <id>http://pchw.github.com/blog/2012/05/27/live</id>
    <content type="html"><![CDATA[<p>RubyMotionは<code>rake</code>でBuildしてSimulatorが立ち上がります．</p>

<p>その後，Terminalはインタラクティブシェルになっていて，そこで行った操作がそのままSimulatorの方に反映されます．</p>

<p>ところが，そのインタラクティブシェルは1行しか打てなくて，そこで色々やろうとすると苦しいものがあります．</p>

<p>そこで登場するのが<strong>motion-live</strong>です．</p>

<p><a href="https://github.com/irrationalfab/motion-live">motion-live</a></p>

<p>これを導入すると，<code>LiveScratchpad.rb</code>というファイルを編集してセーブしたタイミングでインタラクティブシェルに引き渡されて実行されます．</p>

<h2>使い方</h2>

<p>まず，motion-liveをインストールします．</p>

<pre><code>$ gem install motion-live
Fetching: colored-1.2.gem (100%)
Fetching: rb-fsevent-0.9.1.gem (100%)
Fetching: motion-live-0.1.gem (100%)
Successfully installed colored-1.2
Successfully installed rb-fsevent-0.9.1
Successfully installed motion-live-0.1
3 gems installed
Installing ri documentation for colored-1.2...
Installing ri documentation for rb-fsevent-0.9.1...
Installing ri documentation for motion-live-0.1...
Installing RDoc documentation for colored-1.2...
Installing RDoc documentation for rb-fsevent-0.9.1...
Installing RDoc documentation for motion-live-0.1...
</code></pre>

<p>その後，プロジェクトのRakefileを編集します．
（既存の<code>motion crate</code>したのがないなら，<code>motion create &lt;hoge&gt;</code>しましょう）</p>

<pre><code>$ more Rakefile
$:.unshift("/Library/RubyMotion/lib")
require 'motion/project'
require 'motion-live'

Motion::Project::App.setup do |app|
  # Use `rake config' to see complete project settings.
  app.name = 'hoge'
end
</code></pre>

<p>変更点は<code>require 'motion-live'</code>を追加しただけです．</p>

<p>あとは，実行します．</p>

<pre><code>$ rake live
</code></pre>

<p>するとSimulatorが立ち上がり，ディレクトリに<code>LiveScratchpad.rb</code>が出来上がるので，編集保存するとインタラクティブシェルで実行されます．</p>

<h2>利点</h2>

<p>motion-liveを使った時の利点です．</p>

<h3>複数行のコードをインタラクティブシェルに読ませれる</h3>

<p>これによって，何回も使う処理をclassとかmethodにして使うとかいうのも簡単にかけます．</p>

<h3>自分の好きなエディタが使える</h3>

<p>インタラクティブシェルではTerminalの上で書くので，補完も効かなければ，キーバインディングも違って色々不便です．</p>

<p>しかし，motion-liveを使うと，<code>LiveScratchpad.rb</code>というファイルを編集出来ればいいのです．</p>

<p>つまり，EmacsやVimも使えますし，補完を効かせれるTextMateやRedcarを使うことも出来ます．
<a href="http://pchw.github.com/blog/2012/05/27/st2/">前の記事</a>で書いたようにSublime Text2も補完を効かせれるようになったので，僕はSublime Text2を使ってます．</p>

<pre><code>app = UIApplication.sharedApplication
delegate = app.delegate
repl(delegate)
@window
</code></pre>

<p>みたいなのを書く時でも，すごい楽なわけです．</p>

<p>セットアップも有効にするのもRakefileに1行追加ですし，簡単で積極的に使って行きたいですね！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sublime Text 2でRubyMotionの補完が出来るようになったぞおおおお]]></title>
    <link href="http://pchw.github.com/blog/2012/05/27/st2/"/>
    <updated>2012-05-27T10:04:00+09:00</updated>
    <id>http://pchw.github.com/blog/2012/05/27/st2</id>
    <content type="html"><![CDATA[<p><img src="/images/st2.png" alt="catch" /></p>

<p>ついに来ました！</p>

<p>いままで，RubyMotionを書いていて補完が効くのはVimとredcarとTextMateだけでした！
ところが，RubyMotionのフォーラムに「[RubyMotion] Sublime Text 2 Support」という質問が投げかけられ，ついに今日そのパッケージが登場しました！</p>

<p><a href="https://github.com/diemer/RubyMotionSublimeCompletions">RubyMotionSublimeCompletions</a></p>

<p>インストール方法は簡単で，</p>

<pre><code>$ cd ~/Library/Application Support/Sublime Text 2/Packages
$ git clone git://github.com/diemer/RubyMotionSublimeCompletions.git
</code></pre>

<p>してSublime Text2を再起動すればOKです．</p>

<p>PackageControlを導入している人なら，</p>

<pre><code>Cmd+Shift+p
Package Control: Add Repository
https://github.com/diemer/RubyMotionSublimeCompletions
Package Control: Install Package
RubyMotionSublimeCompletions
</code></pre>

<p>でインストール出来るはずです．</p>

<p>後は，普通にエディタを起動して<code>UIApp</code>とか打てば，補完に<code>UIApplication</code>とか<code>UIAppearance</code>とか出るようになります！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyMotionが1.4->1.5->1.6とアップデートしたよ！]]></title>
    <link href="http://pchw.github.com/blog/2012/05/23/update/"/>
    <updated>2012-05-23T01:03:00+09:00</updated>
    <id>http://pchw.github.com/blog/2012/05/23/update</id>
    <content type="html"><![CDATA[<p>気づいたら，RubyMotionの更新が1.5・1.6と続いてありました．</p>

<pre><code>$ sudo motion update
</code></pre>

<p>しましょう．</p>

<h2>RubyMotion 1.5 更新内容</h2>

<pre><code>= RubyMotion 1.5 =

  * Improved the REPL to support multi-line expressions.
  * Fixed a bug when compiling Core Data model files where the `momc' utility
    was not given absolute paths.
  * Removed legacy MacRuby code that was using the private `isaForAutonotifying'
    selector and causing a warning during an App Store submission.
  * Fixed a bug in Enumerable#sort_by that would lead to a crash.
  * Fixed a bug in the REPL where it would not detect the iOS Simulator window
    if certain windows were in front or created later.
  * Fixed a bug in the build system where framework dependencies would not be
    properly handled.
  * Added support for .lproj directories (i18n). Thanks Aaron Hurley.
  * Fixed a bug where objects from pure Ruby classes sent to KVO would not be
    properly handled later (because KVO inserts a new singleton class).
  * Fixed attr_writer to emit KVO notifications (will/didChangeValueForKey).
</code></pre>

<ul>
<li>REPLが複数行をサポート</li>
<li>CoreDataモデルファイルをコンパイル時のバグを修正</li>
<li>レガシーなMacRubyコードを撤去した．</li>
<li>Enumerable#sort_byがクラッシュを引き起こす問題を修正</li>
<li>ウィンドウがシミュレータウィンドウの前に複数あるなどの原因でREPLがシミュレータを見つけれないバグを修正</li>
<li>ビルド時にフレームワークの依存関係を正しく扱えなかったバグを修正</li>
<li>.lprojディレクトリをサポート</li>
<li>pure RubyのクラスのオブジェクトをKVOに送った時に正しくハンドリング出来なかったバグを修正</li>
<li>attr_writerがKVO notificationを上げるように修正</li>
</ul>


<h2>RubyMotion 1.6 更新内容</h2>

<pre><code>= RubyMotion 1.6 =

  * Fixed a regression in the build system introduced by the previous update
    (when compiling .xib files).
  * Fixed the vendoring system to include all source code files. Merged patch
    from https://groups.google.com/d/msg/rubymotion/tPCxSMCA2f4/w2DIHFo2AVAJ
  * Fixed the REPL to not crash if you give it an empty expression.
</code></pre>

<ul>
<li>ビルド時の再発バグの修正</li>
<li>外部ライブラリ読み込み不具合修正</li>
<li>REPLに空を渡した時にクラッシュする不具合の修正</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RubyMotionでGCDを使う]]></title>
    <link href="http://pchw.github.com/blog/2012/05/22/gcd/"/>
    <updated>2012-05-22T22:35:00+09:00</updated>
    <id>http://pchw.github.com/blog/2012/05/22/gcd</id>
    <content type="html"><![CDATA[<p><img src="https://lh6.googleusercontent.com/-nEOFLDxo0SE/T7cKmnkUM3I/AAAAAAAAAac/F_9TagXzXTE/s300/gcd.png" alt="GCD" /></p>

<p>今日はRubyMotionでGCD(Grand Central Dispatch)を使う話です．</p>

<h2>GCD とは</h2>

<p>GCDというのは，</p>

<blockquote><p>非常に効率的なシステム機能と使い勝手のよいプログラミングモデルを併用して，マルチプロセッサを最大限に活用するために必要なコードを徹底的に簡素化</p></blockquote>

<p>するものらしいです
（AppleのGrand Central Dispatchの説明より）</p>

<p>UITableViewとかそういうのはMainThreadでちょっと重い処理をすると，すぐにパフォーマンスが悪くなってなんだこのアプリ糞だな！とか言われるので，そういう時には別Threadを立ててMainThreadの処理を邪魔しないように処理を行う必要があります．
それを楽にしてくれるのがGCD．</p>

<h2>Objective-C</h2>

<p>Obj-Cのコードだと，</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_async(queue, ^{
    // 処理
});
</code></pre>

<p>こんな感じになります．</p>

<h2>RubyMotion</h2>

<p>RubyMotionでは，GCD関連は<code>Dispatch</code>クラスを使います．</p>

<p><a href="http://www.rubymotion.com/developer-center/guides/runtime/#_grand_central_dispatch">RubyMotion Runtime Guid</a> にも書いてます．</p>

<p>上で書いたObj-CのコードをRubyMotionで書きなおすと，</p>

<pre><code>Dispatch::Queue.concurrent.async{
    # 処理
}
</code></pre>

<p>こうなります．超簡単．</p>

<h2>UIの更新に関して</h2>

<p>さて，実際にはConcurrent Dispatch Queueで時間のかかる処理を行い，
処理を行った結果をUIに反映させることがよくあります．
その場合に直接UIへ値を代入とかすると落ちます．
UIはMainThreadから更新しなければなりません．
その場合は，</p>

<pre><code>Dispatch::Queue.concurrent.async{
    # 処理
    Dispatch::Queue.main.async{
        #UI更新
    }
}
</code></pre>

<p>このように<code>Dispatch::Queue.main</code>でMain Dispatch Queueに更新処理を入れることで実現できます．</p>

<h2>実戦</h2>

<p>実際に少し書いてみます．</p>

<pre><code>$ motion create gcd
$ cd gcd
</code></pre>

<h3>app/app_delegate.rb</h3>

<pre><code>class AppDelegate
  def application(application, didFinishLaunchingWithOptions:launchOptions)
    @window = UIWindow.alloc.initWithFrame UIScreen.mainScreen.bounds
    @window.rootViewController = NSBundle.mainBundle.loadNibNamed(
        'RootViewController', 
        owner: self,
        options: nil).first
    @window.rootViewController.wantsFullScreenLayout = true
    @window.makeKeyAndVisible
    true
  end
end
</code></pre>

<h3>InterfaceBuilder</h3>

<p><code>resouces/RootViewController.xib</code> という形でUIButton(Tag 2)，UILabel(Tag 1)を追加しておいて下さい．
（参考：<a href="http://pochixpochi.blogspot.jp/2012/05/rubymotion-interfacebuilder.html">[RUBYMOTION] INTERFACEBUILDERと合わせて使って楽をしよう</a>）</p>

<h3>app/root_view_controller.rb</h3>

<pre><code>class RootViewController &lt; UIViewController
    def viewDidLoad
        @label = view.viewWithTag 1
        @button = view.viewWithTag 2
        @button.addTarget(
            self,
            action: 'onClicked:',
            forControlEvents:UIControlEventTouchUpInside)
    end

    def onClicked(sender)
        p "onClicked"

        Dispatch::Queue.concurrent.async {
            NSThread.sleepForTimeInterval 5
            Dispatch::Queue.main.async {
                @label.text = ["hoge", "fuga", "moge"].sample
            }
        }
    end
end
</code></pre>

<h3>実行</h3>

<pre><code>$ rake
</code></pre>

<p>シミュレータが立ち上がり，Buttonを押すとLabelの文字列がちょっと待ったあとに変わります．
連打すると次々変わると思います．
その間Buttonが押せないとかそういうことが起こらないのが分かると思います．</p>
]]></content>
  </entry>
  
</feed>
